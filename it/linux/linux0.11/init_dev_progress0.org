** 设备环境初始化及激活进程0
*** 设置根设备,硬盘
    bootsect已写入机器系统数据0x901FC的根设备为软盘信息
  #+BEGIN_SRC 
  //代码路径：init/main.c：
……
#define DRIVE_INFO（*（struct drive_info *）0x90080）//硬盘参数表，参看机器系统数据
#define ORIG_ROOT_DEV（*（unsigned short *）0x901FC）//根设备号
……
struct drive_info{char dummy[32]；}drive_info；//存放硬盘参数表的数据结构
void main（void）
{
  ROOT _DEV=ORIG_ROOT_DEV；//根据bootsect中写入机器系统数据的信息设置根设备为软盘
  drive _info=DRIVE_INFO；//的信息，设置为根设备
  ……
}
  #+END_SRC
设置根设备为软盘及硬盘参数表完成后数据在内存位置:[[file:./img/init_dev_addr.jpg
]]
*** 规划物理内存格局,设置缓冲区,虚拟盘,主内存 
**** 内核代码和数据占内存空间
**** 其余物理内存分为:
***** 主内存
      主内存区是进程代码运行的空间，包括内核管理进程数据结构
***** 缓冲区
      主机与外设进行数据交互的中转站
***** 虚拟盘
*** 设置虚拟盘空间并初始化
    我们设定本书所用计算机有16 MB的内存，有虚拟盘，且将虚拟盘大小设置为2 MB。操作系统从缓冲区的末端起开辟2 MB内存空间设置为虚拟盘，主内存起始位置后移2 MB至虚拟盘的末端
*** 内存管理结构mem_map初始化
    系统调用mem_init()函数，对主内存区的管理结构进行设置
*** 初始化块设备请求项结构 
    linux0.11将外设分两类: 一类是块设备,一类是字符设备.
#+BEGIN_EXAMPLE
    进程要想与块设备进行沟通,必须经过主机内存的缓冲区,请求项管理结构request[32]就是操作系统管理缓冲区中的缓冲块与块设备上逻辑块之间读写关系的数据结构
作系统根据所有进程读写任务的轻重缓急，决定缓冲块与块设备之间的读写操作，并把需要操作的缓冲块记录在请求项上，得到读写块设备操作指令后，只根据请求项中的记录来决定当前需要处理哪个设备的哪个逻辑块。
#+END_EXAMPLE
*** 开机启动时间设置
#+BEGIN_EXAMPLE
具体执行步骤是：CMOS是主板上的一个小存储芯片，系统通过调用time_init（）函数，先对它上面记录的时间数据进行采集，提取不同等级的时间要素，比如秒（time.tm_sec）、分（time.tm_min）、年（time.tm_year）等，然后对这些要素进行整合，并最终得出开机启动时间（startup_time）
#+END_EXAMPLE
*** 初始化进程0
    进程0是linux操作系统中运行的第一个进程 ,也是linux父子进程创建机制的第一个父进程.
- 系统初始化进程0.
    进程0管理结构task_struct的母本(init_task={INIT_TASK,}),要将进程0的task_struct中的LDT，TSS,GDT相挂接,并对GDT，task[64]以及进程调度相关的寄存器进行初始化设置.
- linux0.11作为一个现代操作系统，支持多进程轮流执行,这要求进程具备参与多进程轮询的能力.系统这里对时钟中断进程设置,以便在进程0运行后,为进程0以及后续由它直接,间接创建出的进程能参与轮转奠定基础
- 进程0具备处理系统调用的能力.每个进程运算时都可能需要与内核进行交互，交互端口就是系统调用程序，系统通过函数set_system_gate将sys_call与IDT相挂接.这样进程0就具备处理系统调用的能力了.
**** 初始化进程0
[[file:./img/init_pro0_gdt.jpg]]

进程0的task_struct由sched.h的INIT_TASK中定义得出,并用INIT_TASK指针初始化task[64]的0项
[[file:./img/init_task_union.jpg]]
sched_init（）函数接下来用for循环将task[64]除进程0占用的0项外的其余63项清空，同时将GDT的TSS1、LDT1往上的所有表项清零
初始化进程0相关的管理结构的最后一步是非常重要的一步，是将TR寄存器指向TSS0、LDTR寄存器指向LDT0，这样，CPU就能通过TR、LDTR寄存器找到进程0的TSS0、LDT0，也能找到一切和进程0相关的管理信息。
[[file:./img/pro0_init_memory.jpg]]
*** 初始化缓冲区管理结构
缓冲区是内存与外设（如硬盘，以后以硬盘为例）进行数据交互的媒介。
操作系统通过hash_table[NR_HASH]、buffer_head双向环链表组成的复杂的哈希表管理缓冲区。
操作系统通过调用buffer_init（）函数对缓冲区进行设置，执行代码如下：
#+BEGIN_EXAMPLE
//代码路径：init/main.c：
void main（void）
{
……
buffer _init（buffer_memory_end）；
……
}
#+END_EXAMPLE
在buffer_init（）函数里，从内核的末端及缓冲区的末端同时开始，方向相对增长、配对地做出buffer_head、缓冲块，直到不足一对buffer_head、缓冲块。
*** 初始化硬盘
硬盘的初始化为进程与硬盘这种块设备进行I/O通信建立了环境基础。
在hd_init（）函数中，将硬盘请求项服务程序do_hd_request（）与blk_dev控制结构相挂接，硬盘与请求项的交互工作将由do_hd_request（）函数来处理，然后将硬盘中断服务程序hd_interrupt（）与IDT相挂接，最后，复位主8259A int2的屏蔽位，允许从片发出中断请求信号，复位硬盘的中断请求屏蔽位（在从片上），允许硬盘控制器发送中断请求信号。
*** 初始化软盘
软盘和软盘驱动器可以分离，合在一起才是一个整体。为了方便起见，本书所述的软盘除特别声明之外都是指软盘驱动器加软盘的整体。
软盘的初始化与硬盘的初始化类似，区别是挂接的函数是do_fd_request，初始化的是与软盘相关的中断。细节可参看初始化硬盘。
*** 开启中断 
现在，系统中所有中断服务程序都已经和IDT正常挂接。这意味着中断服务体系已经构建完毕，系统可以在32位保护模式下处理中断，重要意义之一是可以使用系统调用。
*** 进程0由0特权级翻转到3特权级,成为真正进程
Linux操作系统规定，除进程0之外，所有进程都要由一个已有进程在3特权级下创建。在Linux 0.11中，进程0的代码和数据都是由操作系统的设计者写在内核代码、数据区，并且，此前处在0特权级，严格说还不是真正意义上的进程。为了遵守规则，在进程0正式创建进程1之前，要将进程0由0特权级转变为3特权级。方法是调用move_to_user_mode（）函数，模仿中断返回动作，实现进程0的特权级从0转变为3
