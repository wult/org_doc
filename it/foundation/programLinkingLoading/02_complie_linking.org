* 编译与链接
** 生成可执行程序过程
 - 预处理
 - 编译
 - 汇编
 - 链接
*** 模块拼装--静态链接
     链接过程包括:地址和空间分配,符号决议,重定位
     符号决议也叫:符号绑定 ,名称绑定,地址绑定,指令绑定.
* 目标文件里有什么
** 目标文件的格式
    windows下的PE(Portable Executable)和Linux的ELF (Executable Linkable Format),它们都是COFF(Common file format)格式的变种.
* 可执行文件的装载与进程
** 进程虚拟地址空间
每个程序运行起来后，将拥有自己的独立 *虚拟地址空间* ,这个虚拟地址空间由计算机硬件平台决定.
C程序中的指针所占的空间来计算虚拟地址空间的大小.
32位平台下4GB虚拟空间不能任意使用，因为程序处于操作系统监控下，进程只能使用那些操作系统分配给进程地址，
linux将进程虚拟地址空间分配为1G为系统使用，3GB用户使用.
** 装载的方式
*** 覆盖装入
*** 页映射
** 从操作系统角度看可执行文件的装载
*** 进程的建立
操作系统角度看，一个进程最关键特征是拥有独立的虚拟地址空间.创建一个进程，装载可执行文件并且执行.最开始只需要做三件事:
- 创建一个独立的虚拟地址空间
  一个虚拟空间由一组页映射函数将虚拟空间各个页映射到相应的物理空间,创建虚拟空间实际是创建映射函数所需要的相应数据结构.在linux下创建虚拟地址空间实际上只是分配一个页目录
- 读取可执行文件头,并且建立虚拟空间与可执行文件映射关系
  上一步是页映射关系函数是虚拟空间到物理内存的映射关系。这步所做的是虚拟空间与可执行文件的映射关系.linux将进程虚拟空间中的一个段叫虚拟内存区域(VMA),操作系统创建进程后，会在进程相应的数据结构中设置一个.text段的VMA
- 将CPU指令寄存器设置成可执行文件的入口地址,启动运行
  操作系统通过设置CPU的指令寄存器将控制权转交给进程.它涉及内核堆栈和用户堆栈切换,CPU运行权限切换.
*** 页错误 
  执行完上述步骤后，可执行文件真正指令和数据都没有被装入内存中,只是建立可执行文件头部信息建立可执行文件和进程虚拟之间映射关系而已.假设在上面例子中,程序入口地址为0x08048000~0x08049000是个空页,于是它就认为这是一个页错误(Page Fault).CPU将控制权交给操作系统，操作系统专门页错误例程来处理这情况，操作系统查询上述第二步的数据结构，找到空页面所在的VMA，计算出相应页面可执行文件的偏移,然后 在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页之间建立的映射关系，然后把控制权再还回进程，进程从刚才页错误位置重新开始执行.
** 进程虚拟空间分布
*** ELF文件链接视图和执行视图
  ELF文件，段权限有:
- 以代码段为代表的权限为可读可执行的段
- 以数据段和BSS段为代码的权限为可读可写的段
- 以只读数据段为代表的权限为只读的段
相同权限的段，把它们合并到一个段进程映射.例如把.text和.init合并.称为Segment.
