* 链接
** 编译器驱动程序
** 静态链接
  为了构造可执行文件,链接器必须完成两个主要任务:
- 符号解析 
    目标文件定义和引用符号.符号解析的目的是将每个符号引用刚好和一个符号定义联系起来.
- 重定位
    编译器和汇编器生成从地址0开始代码和数据节.链接器通过把每个符号定义与一个存储器位置联系起来,然后修改所有对这些符号的引用，全它们指向这个存储器位置，从而重定位这些节.
** 目标文件
- 可重定位目标文件 
    包含二进制代码和数据,其形式可以在编译时与其他重定位目标文件合并起来，创建一个可执行目标文件
- 可执行目标文件
    其形式可以被直接拷贝至存储器并执行
- 共享目标文件
    一种特殊类型的可重定位目标文件,可以在加载或者运行时被动态地加载到存储器并链接
#+BEGIN_EXAMPLE
编译器和汇编器生成可重定位目标文件(包括共享目标文件).
链接器生成可执行目标文件.
目标模块:一个字节序列
目标文件:就是一个存放在磁盘文件中的目标模块.
#+END_EXAMPLE
** 可重定位目标文件
    ELF头(ELF header)以一个16字节的序列开始,这个序列描述了生成该文件的系统的字大小和字节顺序.ELF关剩下部分包含帮助链接器语法分析和解释目标文件的信息.包括ELF头大小，目标文件类型(如可重定位,可执行，或共享),机器类型(IA32),节头部表(section header table)的文件偏移,以前节头部表中条目大小数量 .
| ELF头     |
| .text     |
| .rodata   |
| .data     |
| .bss      |
| .symtab   |
| .rel.text |
| .rel.data |
| .debug    |
| .line     |
| .strtab   |
| 节头部表      |
其中 ELF头 到 .strtab部分为 节,节头部表  为 描述目标文件的节
- .text 
  已编译程序的机器代码
- .rodata
  只读数据
- .data
  已初始化全局C变量。局部C变量在运行时保存在栈中,即不出现.data节中，也不出现在.bss节中
- .bss
  未初始化的全局C变量.在目标文件中这个节不占据实际的空间,只是点位符.分.data和.bss主要是为了空间效率，目标文件中，未初始化变量不需要占据任何实际磁盘空间
- .symtab
  符号表,存放在程序中定义和引用的函数和全局变量的信息.每个可重定位目标文件在.symtab中都有一张符号表，.symtab符号表不包含局部变量的条目
- .rel.text 
  一个.text节中位置的列表,当链接器把这个目标文件和其他文件结合时，需要修改这些位置，一般而言，任何调用外部函数或引用全局变量的指令都需要修改。另一方面，调用本地函数指令则不需要修改.
- .rel.data
  被模块引用或定义的任何全局变量的重定位信息.一般而言，任何已初始化全局变量，如果它初始值是一个全局变量地址或者外部定义定义函数地址,都需要被修改.
- .debug
  调试符号表
- .line
  原始C程序的行号和.text节中机器指令之间的映射.
- .strtab
  一个字符表，其内容包括.symtab和.debug节中符号表以及节头部中节名字。
** 符号和符号表
  第个可重定位目标模块m都有一个符号表，它包含m所定义和引用符号的信息。链接器上下文中，有三种不同的符号:
- 由m定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的C函数以及被定义不带C static属性的全局变量 
- 由其他模块定义并被模块m引用的全局符号。这些符号为外部符号(external).
- 只被模块m定义和引用的本地符号。有的本地链接器符号对应带static属性的C函数和全局变量。这些符号在模块m中随处可见，但不能被其他模块引用
** 重定位
重定位由两步组成
- 重定位节和符号定义
  链接器将所有相同类型节合并为同一类型新聚合节，链接器将运行时存储器地址赋给新聚合节，程序中每个指令和全局变量都有唯一运行时存储器地址
- 重定位节中的符号引用
  链接器修改代码节和数据节中对每个符号的引用，使用它们指向正确运行时的地址.为了执行这一步，链接器依赖称为重定位条目
*** 重定位条目 
  无论何时汇编器遇到对最终位置未知的目标引用，它就会生成： *重定位条目* ,告诉链接器将目标文件合成可执行文件时，如何修改这个引用 ,代码重定位条目放在 .rel.text中,数据重定位条目放在.rel.data
  ELF定义 11种不同重定位类型，关心两种最基本重定位类型:
- R_386_PC32
  重定位一个使用32位PC相对地址的引用 .一个PC相对地址就是距程序计数器PC的当前运行时值的偏移量.当执行一条使用PC相对寻址指令时,它就将在指令中编码的32位值加上PC的当前运行时值,得到有效地址(如call指令的),PC值通常是存储器中下一条指令地址.
- R_386_32
  重定位一个使用32位绝对地址的引用 .通过绝对寻址,CPU直接使用在指令中编码的32位值作为有效地址，不需要进一步修改.
** 可执行目标文件
| ELF头部  |
| 段头部表 |
| .init    |
| .text    |
| .rodata  |
| .data    |
| .bss     |
| .symtab  |
| .debug   |
| .line    |
| .strtab  |
| 节头表      |
ELF头部 到 .rodata 为只读存储器段(代码段)
.data 到 .bss 为读写存储器（数据段）

