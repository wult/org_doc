* 异常控制流
    从给处理器加电开始,直到断电为止，程序计数器假设一个值的序列:
    
    a_0,a_1,...,a_n-1

    其中,每个a_k是某个相应指令I_k的地址.每个从a_k到a_k+1的过渡为控制转移(flow of control或control flow)
    
    现代系统通过使控制发生突变来对这些情况做出反应。我们把这些突变称为异常控制流(Exceptional Control Flow,ECF)
    
    理解ECF很重要:
- 理解ECF将帮助你理解重要的系统概念. ECF是操作系统用来实现IO，进程和虚拟存储器基本机制。
- 理解ECF将帮助你理解应用程序是如何与操作系统交互的.应用程序通过使用一个叫 陷阱 (trap)或者系统调用(system call)的ECF形式,向操作系统请求服务.比如向磁盘写数据，从网络读取数据，创建一个新进程,以及终止当前进程，都是通过应用程序调用系统调用来实现。
- 理解ECF将帮助你编写有趣的新应用程序。 操作系统为应用程序提供了强大ECF机制，用来创建新进程，等待进程终止，通知其他进程系统中异常事件，以及检测和响应这些事件。如果理解ECF机制，那么你就能用它们来编写UNIX外壳和web服务器。
- 理解ECF将帮助你理解并发 ECF是计算机系统中实现并发的基本机制，中断应用程序，进程和线程（它们执行在时间上是重叠的）执行的异常处理程序和中断应用程序执行的信号处理程序都是运行中的并发例子.
- 理解ECF将帮助你理解软件异常如何工作.像c++和java这样的语言通过try,catch以及throw语句提供软件异常机制，软件异常允许程序进行非本地跳转（违反通过的调用/返回栈规则的跳转）来响应错误情况.非本地跳转是一种应用层的ECF，在C中是通过setjmp和longjmp函数提供的。理解这些低级函数将帮助你理解高级软件异常如何得以实现。
** 异常
  异常是异常控制流的一种形式，它一部分是由硬件实现的，一部分是由操作系统实现的。

  *异常* 是控制流中突变，用来响应处理器状态中某些变化。当处理器状态中发生一个重要的变化时，处理器正在执行某个当前指令I_curr。在处理器中，状态被编码为不同的位和信号，状态变化称为事件,事件可能和当前指令的执行直接相关。比如发生虚拟存储器缺页，算术溢出，或者一条指令试图除以0,另一方面，事件也可能和当前指令的执行没有关系。比如一个系统定时器产生信号或者一个IO请求完成。
当处理器检测到有事件发生，它会通过一张叫做异常表(exception table)的跳转表，进行一个间接过程调用(异常)，到一个专门设计用来处理这类事件的操作系统子程序(异常处理程序(exception handle))
 
  当异常处理程序完成处理后，根据引起异常的事件类型,会发生以下三种情况:
- 处理程序将控制返回给当前指令I_curr,即当事件发生时正在执行的指令。
- 处理程序将控制返回给I_next,即如果没有发生异常将会执行下一条指令
- 处理程序终止被中断程序
*** 异常处理
  系统中可能的每种类型的异常都分配一个唯一的非负整数的异常号(exception number).其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核(操作系统常驻存储器的部分)的设计者分配的.前者示例包括0除，缺页，存储器访问违例，断点，后者包括系统调用来自外部IO设备信号

  在系统启动时，操作系统分配和初始化一张称为异常表的跳转表，使得条目k包含异常k的处理程序地址。

  异常表的起始地址放在异常表基址寄存器(ETBR)的特殊CPU寄存器里.
**** 异常调用过程
- 过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中，然而，根据异常类型，返回地址要么是当前指令(当事件发生时正在执行的指令),要么是下一条指令(如果事件不发生，将会在当前指令后执行的指令)
- 处理器也把一些额外的处理器状态压到栈里,在处理程序返回时，重新开始被中断的程序会需要这些状态，比如，一个IA32系统将包含当前条件码和其他内容的EFLAGS寄存器压入栈中。
- 如果控制从一个用户程序转移到内核，那么所有这些项目都被压到内核栈中，而不是压到用户栈中。
- 异常处理程序运行在内核模式下,意味着它们对所有系统资源都有完全的访问权限

一旦硬件触发异常，剩下的工作是由异常处理程序在软件中完成。在处理程序处理完事件之后，它通过执行一条特殊“从中断返回”指令，可选地返回到被中断的程序，该指令将适当的状态弹回到处理器的控制和数据寄存器中，如果异常是一个用户 程序，将状态恢复为用户模式，然后 将控制返回给被中断程序。
*** 异常的类别
**** 中断 
   *中断* 是异步发生的，是来自处理器外部的IO设备信号的结果。硬件中断不是由任何一条专门的指令造成的,从这个意义上说它是异步的，硬件中断的异常处理程序通常称为中断处理程序。
| 类别 | 原因             | 异步/同步 | 返回行为             |
| 中断 | 来自IO设备的信号 | 异步      | 总是返回到下一条指令 |
| 陷阱 | 有意的异常       | 同步      | 总是返回到下一条指令 |
| 故障 | 潜在可恢复的错误 | 同步      | 可能返回到当前指令   |
| 终止 | 不可恢复的错误   | 同步      | 不会返回             |
   在当前指令完成执行后，处理器注意到中断引脚的电压变高了，就从系统总线读取异常号，然后调用适当的中断处理程序。当处理程序返回时，它就将控制返回给下一条指令(即如果没有发生中断，在控制流中会在当前指令之后那条指令)。结果是程序继续执行，就好像没有发生过中断一样。
   剩下的异常类型(陷阱，故障和终止)是同步发生，执行当前指令结果。把这类指令叫做故障指令(faulting instruction)
**** 陷阱和系统调用
    陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令.陷阱最重要用途是在用户程序和内核之间提供一个像过程一样接口，叫系统调用。
#+BEGIN_EXAMPLE
用户程序经常需要向内核请求服务，比如读一个文件(read),创建一个新进程(fork),加载一个新程序(execve),或者终止当前程序(exit).为了允许对这些内核服务的受控访问，处理器提供了一条特殊"syscall n"指令.当用户程序想要请求服务n时，可以执行这条指令。执行syscall指令会导致一个到异常处理程序的陷阱，这些处理程序对参数解码，并用户适当的内核程序。从程序员角度来看，系统调用和普通的函数调用是一样的，但是实现是非常不同的，普通函数运行在用户模式(user mode)中，用户模式限制了函数可以执行的指令的类型，而且它们只能访问与调用函数相同的栈。系统调用运行在内核模式(kernel mode)中，内核模式允许系统调用执行指令，并访问定义在内核中的栈。
#+END_EXAMPLE
**** 故障
    故障由错误情况引起的.它可能能被故障处理程序修正，当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它，否则处理程序返回到内核中的abort例程,abort例程序会终止引起故意的应用程序。

    经典的故障示例是缺页异常，当指令引用一个虚拟地址，而与地址相对应的物理页面不在存储器中，因此必须从磁盘中取出时，就会发生故障。一个页面就是虚拟存储器的一个连续的块(4KB),缺页处理程序从磁盘加载适当的页面，然后将控制返回给引起故障的指令，当指令再次执行时，相应的物理页面已经驻留在存储器中了，指令就可以没有故障地运行完成了。
**** 终止
    终止是不可恢复的致使错误造成的结果,通常是一些硬件错误，比如DRAM或SRAM位被损坏时发生奇偶错误。终止处理程序从不将控制返回给应用程序。终止处理程序从不将控制返回应用程序。处理程序将控制返回给一个abort例程，该例程序会终止这个应用程序。
*** Linux/IA32 系统中的异常
    0~31号码对应的是由INTEL架构师定义的异常，32～255号码对应的是操作系统定义的中断和陷阱.
**** Linux/IA32故障和终止
***** 除法错误
***** 一般保护故障
***** 缺页
***** 机器检查
*** Linux/IA32系统调用
    在IA32系统上，系统调用是通过一条称int n的陷阱指令来提供的。其中n可能是IA32异常表的256个条目中任何一个索引.

    c程序用syscall函数可以直接调用任何系统调用。然而，实际几乎没有必要这么做，大多数系统调用，标准C库提供了一组方便的包装函数。我们将系统调用和它们相关联的包装函数称为系统级函数。
** 进程
    *异常* 是允许操作系统提供进程(process)的概念所需要的基本构造块.进程经典的定义是一个执行中的程序的实例。系统每个程序都是运行在某个进程的上下文(context)中的。上下文由程序正确运行所需的状态组成的。这个状态包括存放在存储器中程序代码和数据，它的栈，通用目的寄存器的内容，程序计数器，环境变量以及打开文件的描述符集合
*** 逻辑控制流
    程序计数器PC，这些值唯一对应于包含在程序的可执行目标文件的指令，或者是包含在运行时动态链接到程序的共享对象中的指令这个PC值的序列叫做逻辑控制流，或逻辑流。
*** 并发流
    计算机系统中逻辑流有许多不同的形式。异常处理程序，进程，信号处理程序，线程和java进程都是逻辑流的例子。
   
    一个逻辑流的执行在时间上与另一个流重叠，称为并发流.两个流被称为并发地运行。

    多个流并发地执行一般现象称为并发(concurrency).一个进程与其他进程轮流运行的概念称为多任务(multitasking).一个进程执行它的控制流的一部分的每一时间段叫做时间片(time slice),因此多任务也叫时间分片(time slicing)
**** 私有地址空间
      进程也为每个程序提供一种假象，好像它独占使用系统地址空间
**** 用户模式和内核模式
    处理器通常是用某个控制寄存器中的一个模式位(mode bit),Linux提供一种聪明的机制叫做 /proc文件系统，它允许用户模式进程访问内核数据结构内容。/proc/cpuinfo是CPU类型，/sys输出关于系统总线和设备额外的低层信息
**** 上下文切换
*** 系统调用错误处理
    当Unix系统级函数遇到错误时，它们典型会返回-1,并设置全局整数变量errno来表示出什么错。
*** 进程控制
**** 获取进程ID
    每个进程都有一个唯 一的正数进程ID（PID）,getpid函数返回调用进程的PID，getppid函数返回它的父进程的PID
 
    getpid和getppid函数返回一个类型为pid_t整数值，在linux系统上它在types.h中被定义为int.
**** 创建和终止进程
    从程序员角度看，进程处于下面三种状态:
- 运行
    进程要么在CPU上执行，要么在等待被执行且最终会被内核调度
- 停止 
    进程的执行被挂起，且不会被调度。当收到SIGSTOP，SIGTSTP，SIDTTIN或者SIGTTOU信号时，进程就停止，并且保持停止直到它收到一个SIGCONT信号 在这时刻，进程再次开始运行.
- 终止
    进程永远停止 ，进程会因为三种原因被终止: 1:收到信号，信号的默认行为是终止进程;2:从主程序返回,3:调用exit函数


    父进程通过调用fork函数创建一个新运行子进程
    新创建的子进程几乎但不完全与父进程相同，子进程得到与父进程用户级虚拟地址空间相同(但是独立)一份copy.包括文本，数据，BSS段，堆 以及用户栈.子进程还获得与父进程任何打开文件描述符相同的copy,这就意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。

    fork函数只被调用一次，却返回两次，一次是在调用进程(父进程)中，一次是在新创建的子进程中，在父进程中，fork返回子进程的PID，子进程中，fork返回0.
**** 回收子进程
    一个进程由于某种原因终止时，内核不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到它的父进程回收。当父进程回收已终止的子进程时，内核将子进程退出状态传递给父进程，然后抛弃已终止的进程。从此这个进程就不存在了，一个终止了但还未被回收的进程称为僵死进程(zombie)
    
    如果父进程没有回收它的zombie子进程就终止了，那么内核就会安排init进程来回收它们.init进程PID为1.

    waitpid函数有点复杂,默认(当options=0时),waitpid挂起调用进程的执行，直到它等待集合中的一个子进程终止。如果等待集合中的一个进程在刚调用的时刻就已经终止，那么waitpid就立即返回。
**** 让进程休眠
     sleep函数将一个进程挂起一段指定时间.
**** 加载并运行程序
     execve函数在当前进程的上下文中加载并运行一个新程序
     
     execve函数加载并运行可执行目标文件filename,且带参数列表argv和环境变量列表envp.只有出现错误时，例如找不到filename,execve才会返回到调用程序。所以与fork一次调用返回两次不同，execve调用一次并从不返回。
** 信号
   Unix信号，它允许进程中断其他进程

   一个信号就是一条小消息,它通知进程系统中发生一个某种类型事件。

   每种信号类型都对应某种系统事件，低层硬件异常是由内核异常处理程序处理的。信号提供一种机制，通知用户进程发生这些异常。比如，如果一个进程试图除以0,那么内核就会发送给它一个SIGFPE信号，如果一个进程执行一条非法指令，那么内核就会发送给它一个SIGILL信号。如果当进程在前台运行时，你键入ctrl-c，内核就会发送一个SIGINT信号给这个前台进程.
*** 信号术语
    传送一个信号到目的进程是由两个不同的步骤组成的:
- 发送信号  内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。发送信号可以有如下两个原因:1:内核检测到一个系统事件，比如除零。 2：一个进程调用了kill函数.显示地要求内核发送一个信号给目的进程，一个进程可以发送信号给它自己。
- 接收信号  当目的进程被内核强迫以某种方式对信号发送做出反应时，目的进程就接收了信号 。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序的用户层函数捕获这个信号。一个只发出，而没有被接收的信号叫做待处理信号.

  一个待处理信号最多只能被接收一次，内核为每个进程在pending位向量中维护着待处理信号的集合。而在blocked位向量中维护着被阻塞的信号集合。只能传送一个类为k的信号
*** 发送信号 
    Unix系统提供了大量向进程发送信号的机制。所有这些机制都是基于进程组(process group)这个概念的.
**** 进程组
     每个进程只属于一个进程组，进程组由一个正整数进程组ID来标识的。getpgrp函数返回当前进程的进程组ID。

     一个子进程和它的父进程同属于一个进程组，一个进程可以通过使用setpgid函数来改变自己或者其他进程的进程组。setpgid函数将进程pid的进程组改为pgid.如果pid是0,那么当前进程的PID。
*** 接收信号
    当内核从一个异常处理程序返回，准备将控制传递给进程p时，会检查进程p的未被阻塞的待处理信号的集合。如果集合为空，那么内核将控制传递到p的逻辑控制流中的下一条指令
*** 信号处理问题
    处理多信号问题
- 待处理信号
 unix信号处理程序通常会阻塞当前处理程序正在处理的类型待处理信号.比如假设一个进程捕获一个SIGINT信号，并且当前正在运行它的SIGINT处理程序。如果另一个SIGINT信号传递到这个进程，那么这个SIGINT将变成待处理的，但是不会被接收，直到处理程序返回
- 待处理信号不会排除等待
 任意类型至多只有一个待处理信号。如果两个类型为k信号传送到一个目的进程，而由于目的进程当前正在执行信号k的处理程序，所以信号k是阻塞的，那么第二个信号就被简单丢弃,它不会排除等待
- 系统调用可以被中断
 像read,wait和accept这样的系统潜在会阻塞进程一段较长时间，称为慢速系统调用。 在某些系统中，当处理程序捕获到一个信号时，被中断的慢系统调用在信号处理程序返回时不再继续，而是立即返回给用户一个错误条件，并将errno设置为EINTR.

     
